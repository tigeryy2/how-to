"""
Generate a formatted index.md for all markdown files in a directory.
"""
import logging
import os
import re
from collections import namedtuple
from logging import getLogger
from pathlib import Path

from typing import TextIO

Header = namedtuple("Header", ["level", "name", "summary"])


def log() -> logging.Logger:
    """
    Provides logger


    :return:
    :rtype:
    """
    return getLogger(__name__)


def get_md_in(directory: Path | str) -> [Path]:
    """
    Given path to some directory, returns list of all markdown files within


    :param directory: Some folder
    :type directory: Path | str
    :return: List of markdown files
    :rtype: list
    """
    log().debug(f"Looking for markdown files in `{directory}`")

    if type(directory) is str:
        directory = Path(directory)

    if not (directory.exists() and directory.is_dir()):
        raise AttributeError(f"Provided path `{directory}` does not exist or is not a folder")

    markdown_files: [Path] = []
    for path in os.listdir(directory):
        log().debug(f"Trying path `{path}`")
        if '.md' in path and str(path).split(".")[1] == "md":
            markdown_files.append(os.path.join(directory, path))

    return markdown_files


def get_headers_from(file: Path | str) -> [Header]:
    """
    Grab headers from markdown file


    :param file: Path to markdown file
    :type file: Path
    :return: List of headers
    :rtype: list
    """
    headers: list[Header] = []

    markdown: [str] = open(file).read()

    # capture 1 or more `#` at the very start of the file, or right after a newline
    # capture the line of text immediately following the `#`s
    # optionally capture the two lines after
    if matches := re.findall(r"(^|\n)(#+)(.*)(\n\n[^#\n\r]*)?", markdown):
        for match in matches:
            # find header level
            level = match[1].count("#")

            # if the two lines after were found, save.
            if len(match) > 3:
                summary = match[3].strip()
            else:
                summary = None
            headers.append(Header(level, match[2].strip(), summary))
    return headers


def write_index_intro(file: TextIO):
    """
    Write introduction for index file.


    :param file: File to write into
    :type file: TextIO
    :return:
    :rtype:
    """
    intro: str = ("# Index\n"
                  "\n"
                  "This index is autogenerated using `scripts/index.py` from all markdown files in `how-to`.\n"
                  "\n"
                  "Run `python scripts/index.py` to re-generate this file.\n"
                  "\n"
                  "## Contents\n"
                  ""
                  "File, title, and summary for each header in the `how-to` directory.\n"
                  "___\n\n")
    file.write(intro)


def write_index(file: TextIO, headers: dict[Path, list[Header]]):
    """
    Given headers, write index to the file


    :param file: File to write to
    :type file: TextIO
    :param headers: Headers extracted from source
    :type headers: dict
    """
    for md_file_path, file_headers in headers.items():
        file_name = str(md_file_path).split(os.sep)[-1]

        # write linked header to the source file
        file.write(f"\n[`{file_name}`]({md_file_path})\n")

        # for each header, write the appropriate number of `#`s, the title, and a link to the
        # section
        for header in file_headers:
            level, name, summary = header
            # on github, spaces are converted to `-` for section header links
            section_link = name.replace(" ", "-")
            file.write(f"{(level - 1) * '    '}- [{name}]({md_file_path}#{section_link})\n")

            # if a summary was found in the original, add it
            if summary:
                file.write(f"{level * '    '}- {summary}\n")

    file.write("___\n")


def generate_index(markdown_directory: Path, destination_path: Path):
    """
    Generate index at the destination from all markdown files in the directory. This will override
    the destination file, and include relative links to the markdown sections.


    :param markdown_directory: Directory with all markdown files. Searching is NOT recursive.
    :type markdown_directory: Path
    :param destination_path: Destination for the index. File will be overwritten.
    :type destination_path: Path
    """
    log().info(
        f"Generating index to `{destination_path}` from markdown files in `{markdown_directory}`")
    markdown_files = get_md_in(markdown_directory)

    headers: dict[Path, list[Header]] = {}
    for file in markdown_files:
        relative_file_path = Path(os.path.relpath(file, start=destination_path.parent))
        headers[relative_file_path] = get_headers_from(file)

    if destination_path.exists():
        os.remove(destination_path)

    with open(destination_path, "w") as file:
        write_index_intro(file)
        write_index(file, headers)


def main():
    logging.basicConfig(level=logging.DEBUG)
    markdown_folder = Path(os.path.join("how-to")).resolve()
    destination_path = Path(os.path.join("index.md")).resolve()
    generate_index(markdown_folder, destination_path)


if __name__ == '__main__':
    main()
